---
layout: post
blogTitle: AoC 2021 in bash
blogImage: aoc-bash.webp
tags:
 - bash
 - aoc
---

I feel <a href="https://adventofcode.com/" target="_blank" rel="noopener">AoC</a> is a nice way to get to know the language of your choice. There's string manipulation, basic mathematics and more. `bash` isn't the ideal language for this task because (in my opinion) it wasn't meant to solve these kind of problems. Nevertheless, I wanted to expand my experience with `bash` and so I'll attempt to solve all the AoC problems using this language.

I might not be able to solve the problems on the same day (heck, I'm starting almost a week late) and might even skip some problems altogether. I also plan to use common tools like `grep`, `sed`, `awk`, etc and not rely on pure bash.

<h1 class="section-header">Index</h1>
<ul>
  <li>Day 01 <a href="#d01p1">part 1</a> <a href="#d01p2">part 2</a></li>
  <li>Day 02 <a href="#d02p1">part 1</a> <a href="#d02p2">part 2</a></li>
  <li>Day 03 <a href="#d03p1">part 1</a> <a href="#d03p2">part 2</a></li>
</ul>

{% include post-heading.html header="Day 01" %}
<h2 class="section-header pt-4" id="d01p1">Part 1</h2>
First, let's get the first value and setup variables
```bash
prev_value="$(head -1 $INP_FILE)"
# keep count in this variable
inc_count=0
# store input file in a variable
INP_FILE="../inp/1"
```

Now, skipping the first line, we need to iterate over the rest and count the changes
```bash
sed -n '2,$p' "$INP_FILE" | while read value; do
    (( value > prev_value )) && (( inc_count++ ))
    prev_value=$value
done
```

Finally, lets print the answer
```bash
echo $inc_count
# Output:
0
```

`WRONG ANSWER`. Umm... what?! After opening the file and confirming that the answer indeed isn't 0, I decided to do some print debugging...
```bash
sed -n '2,$p' "$INP_FILE" | while read value; do
    (( value > prev_value )) && (( inc_count++ ))
    echo $inc_count
    prev_value=$value
done
```
...and surely, non zero values were being printed:
```bash
...
1398
1399
1400
1400
```
<a href="https://stackoverflow.com/q/4667509" target="_blank" rel="noopener">This</a> confirmed my doubt that the piped `while` loop was actually running inside a subshell.

A fix, also mentioned in the post was to wrap the `while` loop and `echo` inside braces to make it be processed by the same subshell.
```bash
sed -n '2,$p' "$INP_FILE" | {
    while read value; do
        (( value > prev_value )) && (( inc_count++ ))
        prev_value=$value
    done
    echo $inc_count
}
```

Note that the variable originally declared outside is still 0.

<h2 class="section-header pt-4" id="d01p2">Part 2</h2>
Firstly, I'll make a function, `part1` that solves part 1. It'll accept a single argument: a filename which has the numbers

We're going to use `paste` and <a href="https://tldp.org/LDP/abs/html/process-sub.html" rel="noopener" target="_blank">process substitution</a> to calculate the window sum.

A little bit of background first: we want to offset the stream of numbers and want to see them side by side, very much like the illustration provided on the website:
```
199  A
200  A B
208  A B C
210    B C D
200  E   C D
207  E F   D
240  E F G
269    F G H
260      G H
263        H
```

Using paste, we can merge two numbers from the lines together:
```bash
paste <(seq 1 5) <(seq 1 5)

# Output:
1	1
2	2
3	3
4	4
5	5
```

We can achieve the offset simply by using `echo`. Also, changing delimiter to +
```bash
paste -d+ <(seq 1 5) <(echo; seq 1 5)

# Output:
1+
2+1
3+2
4+3
5+4
+5
```

Passing this to `bc` will give us the sum for valid windows and print `(standard_in) [NUMBER]: syntax error` to stderr, which will get ignored anyways ;)

Putting it all together:
```bash
tmpfile="$(mktemp)"

# calculate sum of 3-interval window
# NOTE: numbers not part of a window will get ignored anyways
paste -d+ "$INP_FILE" <(echo; cat "$INP_FILE") <(echo; echo; cat "$INP_FILE") | bc > "$tmpfile" 2>/dev/null

part1 "$tmpfile"

rm "$tmpfile"
```

{% include post-heading.html header="Day 02" %}
There was nothing surprising or special about my solution for Day 02 so I'll just put them here:

<h2 class="section-header pt-4" id="d02p1">Part 1</h2>
```bash
function part1 {
    horizontal=0
    depth=0

    while read directive value; do
        case $directive in
            forward)
                (( horizontal += value ))
                ;;
            down)
                (( depth += value ))
                ;;
            up)
                (( depth -= value ))
                ;;
        esac
    done < "$INP_FILE"

    echo $(( horizontal * depth ))
}
```

<h2 class="section-header pt-4" id="d02p2">Part 2</h2>
```bash
function part2 {
    horizontal=0
    depth=0
    aim=0

    while read directive value; do
        case $directive in
            forward)
                (( horizontal += value ))
                (( depth += value * aim ))
                ;;
            down)
                (( aim += value ))
                ;;
            up)
                (( aim -= value ))
                ;;
        esac
    done < "$INP_FILE"

    echo $(( horizontal * depth ))
}
```

{% include post-heading.html header="Day 03" %}

<h2 class="section-header pt-4" id="d03p1">Part 1</h2>
First, I'll define a few global variables that'll come handy in the solution. `INP_FILE`, like all other solutions and `N_COLS`.
Since the number of columns in each line is fixed, we can simply check the characters in the first line and remove 1 for the newline character.
```bash
# this counts the newline too
N_COLS="$( head -1 "$INP_FILE" | wc -c )"
# account for that
(( N_COLS-- ))
```

With that done, I define a helper function that takes a file and calculates each columns' sum (actually, it counts the number of lines that have a 1 at that place).
I use `cut` to only look at that specific column.
```bash
function count_set_bits {
    # count set bits at each position
    set_bit_counts=()

    for (( i=1; i <= N_COLS; i++)); do
        set_bit_counts+=("$( cut -c $i "$1" | grep 1 | wc -l )")
    done

    # "return" the bit count
    echo "${set_bit_counts[@]}"
}
```
This will contain the number of rows that have 1 at those columns.

Now, part 1 is trivial:
```bash
function part1 {
    set_bit_counts=($( count_set_bits "$1" ))
    # use redirection to avoid filename
    n="$( wc -l < "$1" )"

    gamma=0
    epsilon=0

    for (( i=0; i < N_COLS; i++ )); do
        (( set_bit_counts[i] > n - set_bit_counts[i] )) && majority_bit=1 || majority_bit=0

        (( gamma = 2 * gamma + majority_bit ))
        (( epsilon = 2 * epsilon + 1 - majority_bit ))
    done

    echo $(( gamma * epsilon ))
}
```

<h2 class="section-header pt-4" id="d03p2">Part 2</h2>
For part 2, we need to continuously filter the list until only one remains. Since the core logic for calculating for Oxygen and Carbon Dioxide is the same, I'll only explain one here.

I'm going to use intermediate files again. This is definitely possible to do without files but this just makes it a little easier.

<h3 class="pt-4">Basic setup</h3>

```bash
o2_candidates="$( cat "$1" )"
tmpfile=`mktemp`

# for keeping track of which bits we've already seen
cur_bit=0
```

<h3 class="pt-4">Counting current number of candidates</h3>
Since the number of rows are changing at every step, we need to keep track of the current count. We also need to recalculate column sum at every step. The sum part is simple because of the function declared earlier (`count_set_bits`)

To get the count of candidates remaining, we can use `wc`:
```bash
wc -l <<< "$o2_candidates"
```

<h3 class="pt-4">Filtering candidates</h3>
The other part of the puzzle is only keeping lines that we want to. This can be achieved by `grep`. When we're looking at the `i`th column, the first `i-1` columns can be anything ("`.`" in regex). So, for example if I want my 6th character to be `Y` and don't care about anything else, I'll use the following regex:
```bash
grep -E "^.{5}Y"
```

For this problem, filtering candidates looks like:
```bash
# ignore for `cur_bit` characters (0 indexed so -1 offset not needed)
# and then look for `set_bit`
o2_candidates="$( grep -E "^.{$cur_bit}${reqd_bit}" <<< "$o2_candidates" )"
```

<h3 class="pt-4">Base 2 to decimal</h3>
`bc` has a special variable called `ibase` that controls the `base` of `i`nput. In case you were wondering, `obase` also exists. So, we can do math in binary and get the result in decimal. For example, multiplying 10 (`1010` in binary) and 5 (`101` in binary):
```bash
bc <<< "ibase=2; 1010 * 101"
# Output:
50
```

<h3 class="pt-4">Full solution</h3>
```bash
function part2 {
    o2_candidates="$( cat "$1" )"
    co2_candidates="$( cat "$1" )"

    tmpfile=`mktemp`

    cp "$1" "$tmpfile"
    cur_bit=0
    while (( n="$( wc -l <<< "$o2_candidates" )" )); (( n > 1 )); do
        set_bit_counts=($( count_set_bits "$tmpfile" ))

        # if number of 1s >= number of 0s
        (( set_bit_counts[cur_bit] >= n - set_bit_counts[cur_bit] )) && reqd_bit=1 || reqd_bit=0

        # ignore for `cur_bit` characters (0 indexed so -1 offset not needed)
        # and then look for `reqd_bit`
        o2_candidates="$( grep -E "^.{$cur_bit}${reqd_bit}" <<< "$o2_candidates" )"
        echo "$o2_candidates" > "$tmpfile"

        (( cur_bit++ ))
    done

    # reset variables
    cur_bit=0
    cp "$1" "$tmpfile"
    while (( n="$( wc -l <<< "$co2_candidates" )" )); (( n > 1 )); do
        set_bit_counts=($( count_set_bits "$tmpfile" ))

        # if number of 0s > number of 1s
        (( n - set_bit_counts[cur_bit] > set_bit_counts[cur_bit] )) && reqd_bit=1 || reqd_bit=0

        co2_candidates="$( grep -E "^.{$cur_bit}${reqd_bit}" <<< "$co2_candidates" )"
        echo "$co2_candidates" > "$tmpfile"

        (( cur_bit++ ))
    done

    echo "ibase=2; $o2_candidates * $co2_candidates" | bc
    rm "$tmpfile"
}
```

{% include post-heading.html header="" %}
My solutions, for both `bash` and very little `rust` can be found <a href="https://github.com/yoogottamk/aoc-2021" target="_blank" rel="noopener">here</a>.
